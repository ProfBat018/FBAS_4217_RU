# Тема урока. JWT Token
## Что мы пройдем ? 
1. Что такое JWT Token?
2. Как его создать?
3. Из чего он состоит ?
4. Как его использовать ?
5. Где его хранить ?


### Что такое JWT Token ?
JWT - JSON Web Token - это стандарт, который определяет способ передачи информации между двумя сторонами в JSON формате.


### Как его создать ?
По сути есть 2 способа создания JWT Token:
1. Самостоятельно
2. С помощью библиотеки

#### Самостоятельно
Для создания JWT Token нам нужно:
1. Создать заголовок. HEADER
2. Создать тело. PAYLOAD
3. Создать подпись. SIGNATURE
4. Скомбинировать все вместе

Что такое HEADER ? 
Это JSON объект, который содержит информацию о том, как должен быть создан JWT Token.
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

Здесь `alg` - алгоритм, который будет использоваться для создания подписи. В данном случае это `HS256` - HMAC SHA256."

HMAC - это принцип проверки целостности данных.
Он работает следующим образом:
1. Берет данные
2. Добавляет к ним секретный ключ
3. Хеширует их
4. Добавляет хеш к данным
5. Передает данные
6. Получатель берет данные
7. Добавляет к ним секретный ключ
8. Хеширует их
9. Сравнивает хеш с хешем, который был передан
10. Если хеши совпадают, то данные не были изменены

При этом создаетс вопрос ? А откуда секретный ключ уже есть у получателя ? 
Ответ простой, секретный ключ известен обеим сторонам. Он передается до создания JWT Token и передачи данных.

В общем у нас есть синхронный и асинхронный вариант.
В синхронном варианте секретный ключ известен обеим сторонам, в асинхронном варианте секретный ключ известен только одной стороне.

Для того, чтобы реализовать синхронный вариант, нам нужно сгенерировать секретный ключ и передать его обеим сторонам.
Это доказывает, что первый запрос по любому будет асинхронным, так как секретный ключа еще нет.

Давайте рассмотрим пример работы `HMAC SHA256` на примере обычной коробки с замком.
Если мы передаем коробку с замком, то мы должны передать ключ от замка, чтобы получатель мог открыть коробку.
Но если мы передадим ключ вместе с ним, то его можно скопировать и открыть коробку. Решение есть, передавать ключ до того, как мы передадим коробку.

Также есть вариант, когда мы можем передать коробку с замком, а ключ от замка передать другим способом.
Этот метод называется асинхронным, так как ключ передается отдельно от коробки.

В нашем случае, мы будем использовать синхронный вариант, так как он проще и понятнее.

Вернемся к нашему HEADER.
В нем есть еще одно поле `typ` - тип токена. В нашем случае это `JWT`.

Что такое PAYLOAD ?
Это JSON объект, который содержит информацию, которую мы хотим передать.
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

В нашем случае мы передаем `sub` - субъект, `name` - имя, `admin` - администратор.
По сути можно сказать что PAYLOAD - это наши данные, которые мы хотим передать.
Там можно послать все что угодно. Например: 

```json
{
"id": "KJNSDKJNF34564356",
"name": "John Doe",
"email": "johndoe@gmail.com",
"admin": "true"
}
```

Что такое SIGNATURE ?

Это подпись, которая создается на основе HEADER и PAYLOAD.
Для того, чтобы создать подпись, нам нужно взять HEADER и PAYLOAD, объединить их в одну строку, и зашифровать секретным ключом.


В итоге мы получим подпись, которая будет выглядеть так:
```json
HMACSHA256(
  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9,
  secret)
```

Как релизовать это в ASP.NET Core ?
Давайте напишем себе roadmap для этого. 

## Атрибут ValidateAntiForgeryToken

AntiForgeryToken - это токен, который генерируется на сервере и передается на клиент.
Он нужен при submit формы, чтобы проверить, что форма отправлена с того же домена, с которого она была получена.
При нажатии на `submit` генерируется токен, который передается на клиаент асинхронно.
Если злоумышленник попытается перехватить запрос, то он не сможет отправить его, так как у него не будет токена.

Для того, чтобы захешировать пароль таким образом, чтобы я его не видел во время Debug нам нужно сделать это на этапе создания пользователя.

С помощью библиотеки `Bcrypt.Net` мы можем захешировать пароль.
Для этого нам нужно сделать следующее:
1. Установить библиотеку `Bcrypt.Net`
2. Создать класс `PasswordHasher`
3. Создать метод `HashPassword`
4. Создать метод `VerifyPassword`


```csharp
public class PasswordHasher
{
    public string HashPassword(string password)
    {
        return BCrypt.Net.BCrypt.HashPassword(password);
    }

    public bool VerifyPassword(string password, string passwordHash)
    {
        return BCrypt.Net.BCrypt.Verify(password, passwordHash);
    }
}
```


