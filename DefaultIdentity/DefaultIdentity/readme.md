# Темы урока:
* ASP.NET Core Identity
* Hashing
* User Claims
* User Roles
* JWT Token
* Cookies


## Hashing

Хеширование - это процесс преобразования входных данных в строку фиксированной длины.
Хеширование используется для хранения конфиденциальной информации в безопасном виде. 
Хеширование - это односторонний процесс, то есть вы не можете получить исходные данные из хеша.

### Сразу про вопросы, которые возникают у студентов:
1. Какой алгоритм хеширования лучше использовать ?
2. Как хеширование одностронее ?

### Ответы:
Есть одностронние алгоритмы хеширования, и двусторонние.

Например SHA256 - односторонний алгоритм хеширования, который используется для хеширования паролей.
Здесь 256 - это длина хеша в битах. Длина хеша зависит от алгоритма хеширования.
Есть также SHA128, SHA512 и т.д. В основном используются SHA256 и SHA512.

Стоит спросить, что такое вообще хеш ? 
Вспомните понятие хеш таблица, где у каждого значения берется свой хеш код и по этому индексу вставляется в 
массив. При это хеш можно вычислять по абсолютно любым данным, например по строке, числу, объекту и т.д.

Разные типы хеширования используют разные алгоритмы, которые вычисляют хеш код. 
SHA - это Secure Hash Algorithm, который использует 32-битные слова и операции на 32-битных словах.
SHA-256 использует 32-битные слова и операции на 32-битных словах, 
SHA-512 использует 64-битные слова и операции на 64-битных словах.

По идее зная, алгоритс шифрования их можно взломать, но это не так просто,
так как для этого нужно перебрать все возможные комбинации, что занимает очень много времени.
Солнечная система существует 4,5 миллиарда лет, и если бы вы могли проверять 1 миллиард хешей в секунду,
вам потребовалось бы 10^56 лет, чтобы перебрать все возможные комбинации.

Но есть уже готовые словари, в которых методом подбора можно взять нужный хеш.

Предположим, что я просто захешировал пароль. Злоумышленних с помощью reverse engineering может взять хеш и
просто найти его в словаре. Чтобы этого избежать, мы добавляем соль к паролю, а затем хешируем его.

В нашем случае соль - это какая случайная строка, которая добавляется к паролю перед хешированием.
Из этого вытекает еще один вопрос. А как наша программа запоминает соль, если она случайная ?

Для этого используется специальный алгоритм, который называется PBKDF2.

PBKDF2 - это алгоритм, который используется для хеширования паролей. 
Он использует соль и количество итераций для генерации хеша.
Количество итераций - это количество раз, которое алгоритм будет повторно применяться к паролю.

Как же этот алгоритм понимает, что это именно соль, а не часть пароля ?
Для этого используется специальный формат хеша, который называется `PBKDF2-SHA1`. Он знает 
как вычислить хеш, используя соль и количество итераций. То есть по факту он даже не извлекает оттуда соль. 

При входк вы пишите пароль, например `Elvin_123`, он его хеширует несколько раз и на одном из этапов
добавляет соль, например `Elvin_123 + salt`. Потом он хеширует это значение и так несколько раз.
И в итоге получается хеш.

При следующем входе вы вводите тот же пароль, он делает то же самое и получает тот же хеш.
При этом для каждого хеша есть свой секретный алгоритм соли, и свой секретный алгоритм итераций.

## User Claims 

В ASP.NET Core Identity есть такое понятие как `Claims`.
Это просто пара ключ-значение, которая хранится в базе данных.
По сути Claims нужен для того, чтобы хранить дополнительную информацию о пользователе и давать 
доступ к определенным ресурсам.

Например, у нас есть пользователь, который имеет роль `Admin`.
Мы хотим, чтобы он имел доступ к определенным ресурсам, например, к странице администратора.
Для этого мы можем добавить ему Claim, например, `Admin`, и проверять наличие этого Claim при входе в систему.

Или мы хотим сделать доступ к странице только для пользователей старше 18 лет, для этого мы можем добавить 
Claim `Age`, и проверять его при входе в систему. 

Раз и навсегда запомните разницу между `Authentication` и `Authorization`.
* `Authentication` - это процесс проверки подлинности пользователя.
* `Authorization` - это процесс проверки прав доступа пользователя.

## Role based authorization vs Claims based authorization

В ASP.NET Core Identity есть два вида авторизации:
* Role based authorization
* Claims based authorization

### Role based authorization

Вы создаете роли, и в зависимости от роли пользователь получает доступ к определенным ресурсам.
Чтобы предоставить для контроллера или метода, нужно написать

Чтобы весь контроллер был доступен только для администратора, нужно написать

```csharp
[Autorize(Roles = "Admin")]
class HomeController : Controller 
{
    public IActionResult Index()
    {
        return View();
    }
}
```

Чтобы определенный метод был доступен только для администратора, нужно написать

```csharp
class HomeController : Controller 
{
    [Autorize(Roles = "Admin")]
    public IActionResult Index()
    {
        return View();
    }
}
```

Если на нужно дать роль нескольким пользователям, то нужно написать

```csharp
[Autorize(Roles = "Admin, User")]
class HomeController : Controller 
{
    public IActionResult Index()
    {
        return View();
    }
}
```

При этом мы заранее можем заготовить сраницу AccessDenied, которая будет показываться, если пользователь не имеет доступа.
После этого нам надо применить его в `Program.cs`

```csharp

builder.Services.ConfigureApplicationCookie(options =>
{
    options.AccessDeniedPath = new PathString("/Identity/Account/AccessDenied");
    options.LoginPath = new PathString("/Identity/Account/Login");
    options.AccessDeniedPath = new PathString("/Identity/Account/AccessDenied");
});
```

### Claims based authorization

В отличие от Role based authorization, здесь мы можем добавлять любые Claims, и в зависимости от них давать доступ к ресурсам.
Например, мы можем добавить Claim `Age`, и проверять его при входе в систему.

К примеру нам нужно разрешить всем пользователям заходить и выбирать товары на сайте, но
чтобы оформить заказ, нужно быть старше 18 лет. Для этого мы можем добавить Claim `Age`, и проверять его при входе в систему.

Тут нужно отметить что одно другому не мешает, то есть мы можем показывать страницу только зарегистрированным пользователям,
но уже при покупке проверять возраст.

`Claim` - это просто пара ключ-значение, которая хранится в базе данных.
По сути Claims нужен для того, чтобы хранить дополнительную информацию о пользователе и давать
доступ к определенным ресурсам.


### Как создать claim ? 

Для этого нужно воспользоваться методом `AddClaimAsync` у `UserManager`.

```csharp
var user = await _userManager.FindByNameAsync(model.UserName);
var claim = new Claim(user.Age.GetType().Name, user.Age.ToString());
await _userManager.AddClaimAsync(user, claim);
```

Как проверить наличие claim ?

Для этого нужно воспользоваться методом `UserManager.GetClaimsAsync`.

```csharp
var user = await _userManager.FindByNameAsync(model.UserName);
var claims = await _userManager.GetClaimsAsync(user);

if (claims.Any(x => x.Type == "Age" && x.Value == "18"))
{
    // do something
}
```

### Где добавлять claim ?

Можно добавлять в `Register.cshtml.cs`, но тут есть один нюанс.
При регистрации пользователь еще не создан, поэтому нужно добавлять claim после создания пользователя.

```csharp
if (result.succeeded)
{
    var user = await _userManager.FindByNameAsync(Input.Email);
    var claim = new Claim(user.Age.GetType().Name, user.Age.ToString());
    await _userManager.AddClaimAsync(user, claim);
}
```

### Где хранить claim ?

Можно хранить в базе данных, или в токене.

Токены мы пока не прошли, поэтому пока что будем хранить в базе данных.

Чтобы хранить в базе данных, нужно добавить таблицу `AspNetUserClaims` в базу данных.

```csharp

public class ApplicationDbContext : IdentityDbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.Entity<IdentityUserClaim<string>>().ToTable("AspNetUserClaims");
    }
}
```

